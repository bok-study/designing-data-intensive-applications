---
발표자: 김완주
발표일: 2023-12-17
---

# Part2 - 분산 데이터

분산된 데이터베이스를 필요로 하는 이유

- 확장성
    - 데이터 볼륨, 읽기 부하, 쓰기 부하가 단일 장비에서 다룰 수 있는 양보다 커지면 부하를 여러 장비로 분배할 수 있다.
- 내결함성 / 고가용성
    - 장비 하나가 죽더라도 애플리케이션이 계속 동작해야 한다면 여러 장비를 사용해 중복성을 제공할 수 있다.
- 지연 시간
    - 전 세계에 사용자가 있다면 사용자와 지리적으로 가까운 곳의 데이터센터에서 서비스를 제공하기 위해서 사용할 수 있다.

## 고부하로 확장

Scale Up

- 확장이 필요하다면 더 강력한 장비를 구매하는 것이 가장 간단한 방법이다.
- 수직 확장
- 용량 확장

해당 방식의 문제점은 비용이 선형적인 추세보다 훨씬 빠르게 증가한다는 것이다.
또한 병목 현상 때문에 두 배 크기의 장비가 반드시 두 배의 부하를 처리할 수 있는 것은 아니다.

- 네트워크 대역폭과 같은 문제
  그리고 하나의 지리적인 위치로 제한되게 된다.

공유 디스크 아키텍처

- 독립적인 CPU와 RAM을 탑재한 여러 장비가 데이터 저장은 장비 간 공유하는 디스크 배열
- 장비는 고속 네트워크로 연결된다.
- 잠금 경합과 오버헤드가 확장성을 제한한다.

### 비공유 아키텍처(shared-nothing)

Scale Out
각 장비나 가상 장비를 `노드`라고 부른다.

- 각 노드는 cpu, ram, disk를 독립적으로 사용한다.
- 노드 간 코디네이션은 일반적인 네트워크를 사용해 소프트웨어 수준에서 수행한다.

특별한 하드웨어를 필요로 하지 않으므로 가격 대비 성능이 가장 좋은 시스템을 사용할 수 있다.
또한 여러 지리적인 영역에 걸쳐 데이터를 분산해 지연 시간을 줄일 수 있다.
최근엔 클라우드 배포를 활용하여 소규모 회사라도 다중 지역 분산 아키텍처가 실현 가능하다.

## 복제 대 파티셔닝

복제

- 같은 데이터의 복사본을 잠재적으로 다른 위치에 있는 여러 노드에 유지한다.
- 즉 중복성을 제공한다.
  파티셔닝
- 큰 데이터베이스를 파티션이라는 작은 서브셋으로 나누고, 각 파티션은 각기 다른 노드에 할당(샤딩)

# Part5 - 복제

복제란

- 여러 장비에 동일한 데이터의 복사본을 유지함.

복제가 필요한 이유

- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄임
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있음
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘림

복제중인 데이터가 시간이 지나도 변하지 않는다면 복제는 쉽지만, 데이터는 변경 될 가능성이 있기 매우 높다.

변경 데이터를 복제하기 위한 세 가지 알고리즘을 이번 장에서 얘기한다.

- 단일 리더(single-leader)
- 다중 리더(multi-leader)
- 리더 X(leaderless)

복제에는 동기식 복제와 비동기식 복제 중 어떤 것을 사용할지, 잘못된 복제본을 어떻게 처리할 지 고려해야 한다.
이러한 트레이드 오프는 데이트베이스의 설정 옵션이다.

## 리더와 팔로워

모든 쓰기는 모든 복제 서버에서 처리되어야 한다.
그렇지 않으면 복제 서버는 더 이상 동일한 데이터를 유지할 수 없다.
이 문제를 해결하기 위한 가장 일반적인 해결책은 **리더 기반 복제(leader-based replication)** 이다.

**서버 중 하나를 `마스터`로 지정한다.**

1. 클라이언트가 데이터베이스에 쓰기를 할 때 요청을 리더에게 보낸다.
2. 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.
3. 새로운 데이터를 기록할 때 마다 `복제 로그(replication log)`나 `변경 스트림(change stream)` 을 팔로워에게 전달한다.
4. 팔로워가 리더로부터 로그를 받으면 동일한 순서로 모든 쓰기를 적용하여 복사본을 갱신한다.

읽기를 할 땐 리더 혹은 팔로워에게 질의할 수 있다.
단, 쓰기는 리더에게만 허용된다.

## 동기식 vs 비동기식 복제

ex) 프로필 이미지를 갱신하는 상황

1. 클라이언트가 리더에게 갱신 요청을 전송한다.
2. 리더는 요청을 받은 후 데이터 변경을 팔로워에게 전달한다.
3. 리더는 클라이언트에게 갱신이 성공했음을 알려준다.

![](/img/part2/5.1.png)

복제는 매우 빠르지만 얼마 정도의 시간이 걸릴지는 보장할 수 없다.
팔로워가 수 분 이상 리더와 떨어질 수 있다.

동기식 장점

- 팔로워와 리더가 일관성 있게 데이터를 유지하는 것을 보장.
- 리더가 작동하지 않아도 팔로워에서 계속 사용 가능
  동기식 단점
- 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다.
- 모든 쓰기를 차단하고 동기 복제 서버가 다시 사용할 수 있을 때까지 기다려야 한다.

만약 여러 노드를 사용 중일 때 하나의 노드만 장애를 발생해도 전체 시스템을 멈추게한다.
그래서 동기식 복제를 사용하려면 **하나만 동기식 복제를 사용**하고 **나머지는 비동기식**으로 하는 것을 의미한다.
이렇게 하면 적어도 두 노드에 데이터의 최신 복사본이 있는 것을 보장한다.
이러한 설정을 **반동기식(semi-synchronous)** 라고 한다.

**리더 기반 복제**는 비동기식으로 구성한다.
리더가 잘못되고 복구할 수 없을 경우 **팔로워에 아직 복제되지 않은 모든 쓰기는 유실**된다.
쓰기가 클라이언트에게 확인된 경우에도 지속성을 보장하지 않는다.
장점

- 팔로워가 잘못되더라도 리더는 쓰기 처리를 계속 할 수 있다.

### 새로운 팔로워 설정

클라이언트는 지속적으로 데이터베이스에 기록하고 데이터는 항상 유동적이기 때문에 표준 파일 복사본은 다른 시점에 데이터베이스의 다른 부분을 보게 된다.

새로운 팔로워 노드 설정은 대개 중단시간 없이 수행할 수 있다.

1. 데이터베이스를 잠그지 않고, 리더의 데이터베이스 스냅숏을 일정 시점에 가져온다.
2. 스냅숏을 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다.
    - 스냅숏이 리더의 복제 로그의 정확한 위치와 연관되어야 한다.
        - postgresql : 로그 일련번호(log sequence number)
        - MySQL : 이진로그 좌표(binlog coordinate)
4. 팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두 처리했을 때 따라잡았다고 말한다.
    - 리더에 발생하는 데이터 변화를 이어서 처리할 수 있다.

### 노드 중단 처리

모든 노드는 중단 시간이 발생할 수 있다.

- 예기치 않은 오류
- 보안 패치를 위한 리부팅

중단시간 없이 개별 노드를 재부팅할 수 있다는 점은 운영과 유지보수에 큰 장점이다.
리더 기반 복제에서 HA는 어떻게 달성 할까?

### 팔로워 장애: 따라잡기 복구

팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관한다.
이렇게 하게되면 복구를 쉽게 진행할 수 있다.

1. 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 확인한다.
2. 팔로워는 리더에 연결해 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청한다.
3. 변경이 다 적용되면 데이터 변경의 스트림을 계속 받을 수 있다.

### 리더 장애: 장애 복구

1. 리더가 장애인지 판단한다.
    1. 대부분 시스템은 TimeOut을 통해 판별한다.
2. 새로운 리더를 선택한다.
    1. 선출 과정을 통해 이전에 선출된 제어 노드에 의해 새로운 리더가 임명될 수 있다.
3. 새로운 리더 사용을 위해 시스템을 재설정 한다.
    1. 새로운 쓰기 요청을 새로운 리더에게 보내야 한다.

**장애 복구 과정은 잘못될 수 있는 것 투성이다.**

- 비동기식 복제를 사용한다면 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있다.
  이러한 경우 충돌하는 쓰기를 발생시킬 수 있다. 가장 일반적인 해결책은 이전 리더의 복제되지 않은 쓰기를 단순히 폐기하는 것이다.
  이러한 방식은 클라이언트의 기대를 저버리게 된다.
- 노드가 모두 자신이 리더라고 믿을 수 있다.(스플릿 브레인(Split Brain))
    - 두 리더가 쓰기를 받으면서 충돌을 해소하는 과정을 거치지 않으면 데이터가 유실되거나 오염된다.
- 리더가 죽었다고 판단하기 위한 적절한 타임아웃을 설정해야한다.

### 복제 로그 구현

### 구문 기반 복제

리더는 모든 쓰기 요청을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송한다.
관계형 데이터베이스는 모든 INSERT, UPDATE, DELETE 구문을 팔로워에게 전달하고, 팔로워는 클라이언트에게 직접 받은 것처럼 SQL 구문을 파싱하고 실행한다.

하지만 이 방법엔 복제가 깨질 수 있다.

- 시간을 얻기 위한 NOW()나 임의의 숫자를 얻기 위한 RAND()와 같은 비결정적 함수를 호출하는 구문은 각 복제 서버마다 다른값을 생성할 가능성이 있다.
- 자동증가 컬럼을 사용하는 구문이나 데이터베이스에 잇는 데이터에 의존한다면 모두 정확히 같은 순서로 실행되어야 한다.
- 부수 효과를 가진 구문(ex. 트리거, 프로시저)은 부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수효과가 발생할 수 있다.

해결책

- 모든 비결정적 함수 호출은 고정 값을 반환하게끔 대체
- 하지만 다른 문제도 있기에 다른 복제방법을 선호한다.

### 쓰기 전 로그 배송

- 로그 구조화 저장소 엔진에선 로그 자체가 저장소의 중요한 주요 부분이다.
    - 로그 세그먼트는 작게 유지되고 백그라운드로 가비지 컬렉션을 한다.
- 개별 디스크 블록에 덮어쓰는 B 트리의 경우 모든 변경은 `쓰기 전 로그(Write-ahead log, WAL)`에 쓰기 때문에 일관성 있는 상태로 색인을 복원할 수 있다.

로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용(append-only) 바이트 열이다.
완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축할 수 있다.
리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송한다.

팔로워가 이 로그를 처리하게 되면 정확히 동일한 데이터 구조의 복제본이 만들어진다.

큰 단점
로그가 제일 저수준의 데이터를 기술한다.
WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 포함한다.
이렇게 하면 복제가 저장소 엔진과 밀접하게 엮인다.
다른 버전으로 변경한다면 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없다.

만약 이것이 허용된다면 팔로워를 먼저 업그레이드 하고 레이드함으로써 중단시간 없이 데이터베이스 소프트웨어 업그레이드 수행이 가능하다.
WAL배송과 같이 복제 프로토콜이 버전의 불일치를 허용하지 않는다면 중단시간이 필요하다.

### 논리적(로우 기반) 로그 복제

다른 로그 형식을 사용하는 방법이다.
복제 로그를 저장소 엔진의 데이터 표현과 구별하기 위해 `논리적 로그(logical log)`라고 부른다.

- 삽입된 로우의 로그는 모든 컬럼의 새로운 값을 포함.
- 삭제된 로우의 로그는 로우를 교유하게 식별하는 정보를 포함
    - 대부분 Primary Key지만, 없다면 모든 컬럼의 예전 값을 로깅해야 한다.
- 갱신된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보와 모든 컬럼의 새로운 값을 포함한다.

여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시한다.

논리적 로그를 내부와 분리했기 때문에 호환성을 더 쉽게 유지할 수 있고, 다른 버전의 데이터베이스 소프트웨어나 다
른 저장소 엔진을 실행할 수 있다.

또한 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉽다.
이런 측면은 외부 시스템에 데이터베이스 내용을 전송하고자 할 때 유용하다.

### 트리거 기반 복제

조금 더 유연한 상황이 필요할 때 트리거나 프로시저를 사용하여 복제할 수 있다.

트리거는 애플리케이션 코드를 등록할 수 있게 하여 데이터가 변경되면 자동으로 실행된다.
데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다.

그러나 많은 오버헤드가 있다.
하지만 유연성이 미쳐서 많이 사용한다.

## 복제 지연 문제

복제는 내결함성 뿐만 아니라 확장성과 지연시간 때문에 한다.

리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하지만, 읽기 전용 질의는 어떤 복제 서버에서도 가능하다.
대부분이 읽기 요청이고 쓰기가 작은 비율로 구성된 작업부하라면 많은 팔로워를 만들어 읽기 요청을 분산시킨다.

**읽기 확장(read-sacling) 아키텍처**는 팔로워를 더 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴 수 있다.
이러한 것은 비동기식 복제에서만 동작한다.
동기식에서 한다면 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기가 불가능해진다.

하지만 비동기 팔로워에서 데이터를 읽을 때 이전 데이터를 읽어올 수도 있다.
동일한 질의를 수행하면 모든 쓰기가 반영되지 않았을 때 다른 결과를 얻을 수 있다.
하지만 이러한 상태는 일시적인 상태에 불과하다.
쓰기를 멈추고 잠시 기다리면 결국 따라잡게 되고 리더와 일치하게 된다.
이런 효과를 **최종적 일관성**이라고 한다.

하지만 지연 시간이 얼마나 길어질 지 확신할 수 없기 때문에 이러할 경우 큰 문제가 될 수 있다.

### 자신이 쓴 내용 읽기

데이터가 제출되면 리더에게 전송해야 하지만, 데이터를 볼 때는 팔로워에서 읽을 수 있다.

사용자가 쓰기를 수행한 직후 데이터를 본다면 복제 서버에 반영되지 않았을 수 있다.
이러할 경우 유실된 것처럼 보이기 때문에 당연히 불만족스러운 동작이다.

![](/img/part2/5.2.png)

이런 상황에서는 **읽기 일관성** 이 필요하다.
페이지를 재로딩 했을 때 모든 갱신을 볼 수 있음을 보장하며 **다른 사용자에 대해서는 보장하지 않는다**.

- 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다.
    - 그 외에는 팔로워에서 읽는다.
    - 예를 들어 사용자 소유의 프로필은 리더에서 읽고, 다른 사용자의 프로필은 팔로워에서 읽는 규칙을 설정한다.
- 쓰기가 많을 경우 효율적이지 않다.
    - 마지막 갱신 시각을 찾아서 마지막 갱신 후 1분동안은 리더에서 모든 읽기를 수행한다.
    - 복제 지연 모니터링해 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다.
- 가장 최근 쓰기의 타임스탬프를 기록하여 갱신한다.
    - 최신 내용이 아닌 경우엔 다른 복제 서버가 읽기를 처리하거나 복제 서버가 따라잡을 때까지 대기시킨다.
- 모든 요청은 리더가 포함된 데이터센터로 라우팅되어야 한다.(?)

동일한 사용자가 여러 디바이스로 접근할 시엔 또 다른 문제가 발생한다.
이러한 경우엔 **디바이스 간 쓰기 후 읽기** 일관성이 제공되어야 한다.

- 마지막 갱신 타임스탬프를 기억해야 하는 방식을 어렵다.
- 동일한 데이터센터로 라우팅 된다는 보장이 없다.

## 단조 읽기

시간이 거꾸로 흐르는 현상이 있을 수 있다.

![](/img/part2/5.3.png)

**단조 읽기(monotonic read)** 는 이상 현상이 발생하지 않음을 보장한다.
강한 일관성보단 덜 하지만 최종적 일관성보다는 더 강한 보장이다.
새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다.

사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 방법이다.
예를 들어 임의 선택보다는 사용자 ID의 해시를 기반으로 복제 서버를 선택한다.
그러나 복제 서버가 고장 나면 질의를 다른 복제서버로 재라우팅 할 필요가 있다.

## 일관된 순서로 읽기

B는 지연없이 바로 전달되더라도 A는 지연이 발생할 수 있다.
이러하면 B -> A 순서로 화면에 보여질 수 있다.

[https://www.notion.so](https://www.notion.so)

이러한 현상은 **일관된 순서로 읽기(Consistent Prefix Read)** 와 같은 다른 유형의 보장이 필요하다.
일련의 쓰기가 특정 순서로 발생한다면 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다.

파티셔닝된 데이터베이스에서 발생하는 특징적인 문제다.
같은 순서로 쓰기를 적용한다면 읽기 또한 일관된 순서를 보기 때문에 이러한 현상은 일어나지 않는다.

## 복제 지연을 위한 해결책

최종적 일관성 시스템으로 작업할 때 지연이 몇 분이나 몇 시간으로 증가한다면 문제가 생긴다.
이러한 상황이 중요하다면 쓰기 후 읽기와 같은 강한 보장을 제공하게끔 설계해야 한다.

또한 복제가 비동기식으로 동작하지만 동기식으로 동작하는 척 하는 것도 문제 해결 방안이다.

이러한 이유로 트랜잭션을 사용한다,